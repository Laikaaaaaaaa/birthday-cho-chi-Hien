<!DOCTYPE html>
<html lang="en">

<head>
  <link rel="Website Icon" type="png" href="https://png.pngtree.com/png-clipart/20210815/original/pngtree-birthday-cake-sticker-vector-illustration-png-image_6626622.jpg">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- Cho phép responsive trên mọi thiết bị -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Birthday Page</title>
  <style>
    /* Import font */
    @import url("https://fonts.googleapis.com/css?family=Kaushan+Script");

    html,
    body,
    .container {
      height: 100%;
      font-family: "Kaushan Script", "Sail", cursive;
      margin: 0;
      padding: 0;
    }

    body {
      background: #e74;
      overflow: hidden;
      background-image: linear-gradient(to bottom, #190e14, #0d0d4b 30%, #c76075 80%, #e9b64b 95%);
      background-image: radial-gradient(circle at center bottom, #e9b64b, #c76075 15%, #0d0d4b 75%, #190e14 90%);
      z-index: 99;
    }

    div#beach,
    canvas#canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 99;
    }

    div#beach {
      background-image: url(https://dl.dropbox.com/s/oe0oce2udq44bj5/beachsil2.png);
      /* background-size: cover; */
      background-position: bottom right;
      background-size: 1700px;
      background-repeat: no-repeat;
    }

    div#video {
      position: absolute;
      right: 243px;
      bottom: 200px;
    }

    div#video iframe {
      width: 255px;
      height: 155px;
    }

    #people {
      position: absolute;
      bottom: 65px;
      left: 40px;
      width: 140px;
    }

    #car {
      position: absolute;
      bottom: 46px;
      left: 180px;
      width: 230px;
    }

    div#sea {
      background-color: blue;
      height: 85px;
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background-image: radial-gradient(circle at center top, #23485a, #0d0246);
    }

    .merrywrap {
      position: absolute;
      right: 0;
      left: 0;
      bottom: 0;
      top: 0;
      background-color: antiquewhite;
      transition: background-color 0.5s ease;
      z-index: 1000;
      height: 102vh;
    }

    .giftbox {
      position: absolute;
      width: 300px;
      height: 200px;
      left: 50%;
      margin-left: -150px;
      top: 40%;
      z-index: 10;
    }

    .giftbox>div {
      background: #d44;
      position: absolute;
    }

    .giftbox>div:after,
    .giftbox>div:before {
      position: absolute;
      content: "";
      top: 0;
    }

    .giftbox:after {
      position: absolute;
      color: #fff;
      width: 100%;
      content: "Click Me!";
      left: 0;
      bottom: 0;
      font-size: 50px;
      text-align: center;
      transform: rotate(-20deg);
      transform-origin: 0 0;
    }

    .giftbox .cover {
      width: 100%;
      top: 0;
      left: 0;
      height: 25%;
      z-index: 2;
    }

    .giftbox .cover:before {
      position: absolute;
      height: 100%;
      left: 50%;
      width: 50px;
      transform: translateX(-50%);
      background: #fdc56d;
    }

    .giftbox .cover>div {
      position: absolute;
      width: 50px;
      height: 50px;
      left: 50%;
      top: -50px;
      transform: translateX(-50%);
    }

    .giftbox .cover>div:before,
    .giftbox .cover>div:after {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      content: "";
      box-shadow: inset 0 0 0 15px #fdc56d;
      border-radius: 30px;
      transform-origin: 50% 100%;
    }

    .giftbox .cover>div:before {
      transform: translateX(-45%) skewY(40deg);
    }

    .giftbox .cover>div:after {
      transform: translateX(45%) skewY(-40deg);
    }

    .giftbox .box {
      right: 5%;
      left: 5%;
      height: 80%;
      bottom: 0;
    }

    .giftbox .box:before {
      width: 50px;
      height: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #fdc56d;
    }

    .giftbox .box:after {
      width: 100%;
      height: 30px;
      background: rgba(0, 0, 0, 0.2);
    }

    .icons {
      position: absolute;
      left: 10px;
      height: auto;
      transform: translateY(10px) rotate(-20deg);
    }

    .icons .row {
      width: 100%;
      text-align: center;
    }

    .icons .row span {
      color: #e5e5e5;
      text-shadow: 4px 4px 0 rgba(96, 125, 139, 0.4);
      font-size: 50px;
      display: inline-block;
      opacity: 0;
      transition: transform 0.5s ease-in, opacity 0.7s;
    }

    .step-1 .giftbox {
      animation: wobble 0.5s linear infinite forwards;
    }

    .step-1 .cover {
      animation: wobble 0.5s linear infinite 0.1s forwards;
    }

    .step-1 .icons .row span {
      opacity: 1;
    }

    .step-2 .giftbox:after {
      opacity: 0;
    }

    .step-3 .giftbox,
    .step-4 .giftbox {
      opacity: 0;
      z-index: 1;
    }

    .step-3 .giftbox:after,
    .step-4 .giftbox:after {
      opacity: 0;
    }

    .step-2 .giftbox .cover {
      animation: flyUp 0.4s ease-in forwards;
    }

    .step-2 .giftbox .box {
      animation: flyDown 0.2s ease-in 0.05s forwards;
    }

    @keyframes wobble {
      25% {
        transform: rotate(4deg);
      }
      75% {
        transform: rotate(-2deg);
      }
    }

    @keyframes flyUp {
      75% {
        opacity: 1;
      }
      100% {
        transform: translateY(-1000px) rotate(20deg);
        opacity: 0;
      }
    }

    @keyframes flyDown {
      75% {
        opacity: 1;
      }
      100% {
        transform: translateY(100%);
        opacity: 0;
      }
    }

    /* Các keyframes và định nghĩa animation khác vẫn giữ nguyên... */

    canvas#c {
      position: absolute;
      top: 0;
      left: 0;
    }

    #balloon-container {
      height: 100vh;
      padding: 1em;
      box-sizing: border-box;
      display: flex;
      flex-wrap: wrap;
      overflow: hidden;
      transition: opacity 500ms;
    }

    .balloon {
      height: 125px;
      width: 105px;
      border-radius: 75% 75% 70% 70%;
      position: relative;
    }

    .balloon:before {
      content: "";
      height: 75px;
      width: 1px;
      padding: 1px;
      background-color: #FDFD96;
      display: block;
      position: absolute;
      top: 125px;
      left: 0;
      right: 0;
      margin: auto;
    }

    .balloon:after {
      content: "▲";
      text-align: center;
      display: block;
      position: absolute;
      color: inherit;
      top: 120px;
      left: 0;
      right: 0;
      margin: auto;
    }

    @keyframes float {
      from {
        transform: translateY(100vh);
        opacity: 1;
      }
      to {
        transform: translateY(-300vh);
        opacity: 0;
      }
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>
  <div id="merrywrap" class="merrywrap">
    <div class="giftbox">
      <div class="cover">
        <div></div>
      </div>
      <div class="box"></div>
    </div>
  </div>
  <canvas id="c"></canvas>
  <div id="balloon-container"></div>

  <script>
    // Chúng ta đặt các tùy chọn cho hiệu ứng chữ trong đối tượng opts.
    // Ban đầu, giá trị mặc định là cho desktop; sau đó sẽ cập nhật theo kích thước màn hình.
    var opts = {
      strings: ['HAPPY', 'BIRTHDAY!', 'CHỊ', 'Hiền'],
      charSize: 120,
      charSpacing: 120,
      lineHeight: 120,
      cx: window.innerWidth / 2,
      cy: window.innerHeight / 2,
      fireworkPrevPoints: 10,
      fireworkBaseLineWidth: 5,
      fireworkAddedLineWidth: 8,
      fireworkSpawnTime: 200,
      fireworkBaseReachTime: 30,
      fireworkAddedReachTime: 30,
      fireworkCircleBaseSize: 20,
      fireworkCircleAddedSize: 10,
      fireworkCircleBaseTime: 30,
      fireworkCircleAddedTime: 30,
      fireworkCircleFadeBaseTime: 10,
      fireworkCircleFadeAddedTime: 5,
      fireworkBaseShards: 5,
      fireworkAddedShards: 5,
      fireworkShardPrevPoints: 3,
      fireworkShardBaseVel: 4,
      fireworkShardAddedVel: 2,
      fireworkShardBaseSize: 3,
      fireworkShardAddedSize: 3,
      gravity: 0.1,
      upFlow: -0.1,
      letterContemplatingWaitTime: 360,
      balloonSpawnTime: 20,
      balloonBaseInflateTime: 10,
      balloonAddedInflateTime: 10,
      balloonBaseSize: 20,
      balloonAddedSize: 20,
      balloonBaseVel: 0.4,
      balloonAddedVel: 0.4,
      balloonBaseRadian: -(Math.PI / 2 - 0.5),
      balloonAddedRadian: -1,
    };

    // Chúng ta lấy canvas "c" để vẽ chữ và hiệu ứng.
    var c = document.getElementById("c"),
      ctx = c.getContext('2d'),
      w = c.width = window.innerWidth,
      h = c.height = window.innerHeight,
      hw = w / 2,
      hh = h / 2,
      letters = [],
      Tau = Math.PI * 2,
      TauQuarter = Tau / 4;

    // Hàm cập nhật các tham số responsive dựa trên kích thước màn hình.
    function updateResponsiveSettings() {
      if (window.innerWidth < 480) {
        opts.charSize = 60;
        opts.charSpacing = 60;
        opts.lineHeight = 60;
      } else if (window.innerWidth < 768) {
        opts.charSize = 80;
        opts.charSpacing = 80;
        opts.lineHeight = 80;
      } else {
        opts.charSize = 120;
        opts.charSpacing = 120;
        opts.lineHeight = 120;
      }
      opts.cx = window.innerWidth / 2;
      opts.cy = window.innerHeight / 2;
      ctx.font = opts.charSize + 'px Verdana';
    }

    updateResponsiveSettings();

    // Định nghĩa đối tượng Letter cho hiệu ứng chữ
    function Letter(char, x, y) {
      this.char = char;
      this.x = x;
      this.y = y;
      this.dx = -ctx.measureText(char).width / 2;
      this.dy = +opts.charSize / 2;
      this.fireworkDy = this.y - hh;
      var hue = x / (opts.charSpacing * Math.max(opts.strings[0].length, opts.strings[1].length)) * 360;
      this.color = 'hsl(' + hue + ',80%,50%)';
      this.lightAlphaColor = 'hsla(' + hue + ',80%,light%,alp)';
      this.lightColor = 'hsl(' + hue + ',80%,light%)';
      this.alphaColor = 'hsla(' + hue + ',80%,50%,alp)';
      this.reset();
    }
    Letter.prototype.reset = function () {
      this.phase = 'firework';
      this.tick = 0;
      this.spawned = false;
      this.spawningTime = opts.fireworkSpawnTime * Math.random() | 0;
      this.reachTime = opts.fireworkBaseReachTime + opts.fireworkAddedReachTime * Math.random() | 0;
      this.lineWidth = opts.fireworkBaseLineWidth + opts.fireworkAddedLineWidth * Math.random();
      this.prevPoints = [[0, hh, 0]];
    }
    Letter.prototype.step = function () {
      if (this.phase === 'firework') {
        if (!this.spawned) {
          ++this.tick;
          if (this.tick >= this.spawningTime) {
            this.tick = 0;
            this.spawned = true;
          }
        } else {
          ++this.tick;
          var linearProportion = this.tick / this.reachTime,
            armonicProportion = Math.sin(linearProportion * TauQuarter),
            x = linearProportion * this.x,
            y = hh + armonicProportion * this.fireworkDy;
          if (this.prevPoints.length > opts.fireworkPrevPoints)
            this.prevPoints.shift();
          this.prevPoints.push([x, y, linearProportion * this.lineWidth]);
          var lineWidthProportion = 1 / (this.prevPoints.length - 1);
          for (var i = 1; i < this.prevPoints.length; ++i) {
            var point = this.prevPoints[i],
              point2 = this.prevPoints[i - 1];
            ctx.strokeStyle = this.alphaColor.replace('alp', i / this.prevPoints.length);
            ctx.lineWidth = point[2] * lineWidthProportion * i;
            ctx.beginPath();
            ctx.moveTo(point[0], point[1]);
            ctx.lineTo(point2[0], point2[1]);
            ctx.stroke();
          }
          if (this.tick >= this.reachTime) {
            this.phase = 'contemplate';
            this.circleFinalSize = opts.fireworkCircleBaseSize + opts.fireworkCircleAddedSize * Math.random();
            this.circleCompleteTime = opts.fireworkCircleBaseTime + opts.fireworkCircleAddedTime * Math.random() | 0;
            this.circleCreating = true;
            this.circleFading = false;
            this.circleFadeTime = opts.fireworkCircleFadeBaseTime + opts.fireworkCircleFadeAddedTime * Math.random() | 0;
            this.tick = 0;
            this.tick2 = 0;
            this.shards = [];
            var shardCount = opts.fireworkBaseShards + opts.fireworkAddedShards * Math.random() | 0,
              angle = Tau / shardCount,
              cos = Math.cos(angle),
              sin = Math.sin(angle),
              x = 1,
              y = 0;
            for (var i = 0; i < shardCount; ++i) {
              var x1 = x;
              x = x * cos - y * sin;
              y = y * cos + x1 * sin;
              this.shards.push(new Shard(this.x, this.y, x, y, this.alphaColor));
            }
          }
        }
      } else if (this.phase === 'contemplate') {
        ++this.tick;
        if (this.circleCreating) {
          ++this.tick2;
          var proportion = this.tick2 / this.circleCompleteTime,
            armonic = -Math.cos(proportion * Math.PI) / 2 + .5;
          ctx.beginPath();
          ctx.fillStyle = this.lightAlphaColor.replace('light', 50 + 50 * proportion).replace('alp', proportion);
          ctx.arc(this.x, this.y, armonic * this.circleFinalSize, 0, Tau);
          ctx.fill();
          if (this.tick2 > this.circleCompleteTime) {
            this.tick2 = 0;
            this.circleCreating = false;
            this.circleFading = true;
          }
        } else if (this.circleFading) {
          ctx.fillStyle = this.lightColor.replace('light', 70);
          ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
          ++this.tick2;
          var proportion = this.tick2 / this.circleFadeTime,
            armonic = -Math.cos(proportion * Math.PI) / 2 + .5;
          ctx.beginPath();
          ctx.fillStyle = this.lightAlphaColor.replace('light', 100).replace('alp', 1 - armonic);
          ctx.arc(this.x, this.y, this.circleFinalSize, 0, Tau);
          ctx.fill();
          if (this.tick2 >= this.circleFadeTime)
            this.circleFading = false;
        } else {
          ctx.fillStyle = this.lightColor.replace('light', 70);
          ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
        }
        for (var i = 0; i < this.shards.length; ++i) {
          this.shards[i].step();
          if (!this.shards[i].alive) {
            this.shards.splice(i, 1);
            --i;
          }
        }
        if (this.tick > opts.letterContemplatingWaitTime) {
          this.phase = 'balloon';
          this.tick = 0;
          this.spawning = true;
          this.spawnTime = opts.balloonSpawnTime * Math.random() | 0;
          this.inflating = false;
          this.inflateTime = opts.balloonBaseInflateTime + opts.balloonAddedInflateTime * Math.random() | 0;
          this.size = opts.balloonBaseSize + opts.balloonAddedSize * Math.random() | 0;
          var rad = opts.balloonBaseRadian + opts.balloonAddedRadian * Math.random(),
            vel = opts.balloonBaseVel + opts.balloonAddedVel * Math.random();
          this.vx = Math.cos(rad) * vel;
          this.vy = Math.sin(rad) * vel;
        }
      } else if (this.phase === 'balloon') {
        ctx.strokeStyle = this.lightColor.replace('light', 80);
        if (this.spawning) {
          ++this.tick;
          ctx.fillStyle = this.lightColor.replace('light', 70);
          ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
          if (this.tick >= this.spawnTime) {
            this.tick = 0;
            this.spawning = false;
            this.inflating = true;
          }
        } else if (this.inflating) {
          ++this.tick;
          var proportion = this.tick / this.inflateTime,
            x = this.cx = this.x,
            y = this.cy = this.y - this.size * proportion;
          ctx.fillStyle = this.alphaColor.replace('alp', proportion);
          ctx.beginPath();
          generateBalloonPath(x, y, this.size * proportion);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, this.y);
          ctx.stroke();
          ctx.fillStyle = this.lightColor.replace('light', 70);
          ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
          if (this.tick >= this.inflateTime) {
            this.tick = 0;
            this.inflating = false;
          }
        } else {
          this.cx += this.vx;
          this.cy += this.vy += opts.upFlow;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          generateBalloonPath(this.cx, this.cy, this.size);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(this.cx, this.cy);
          ctx.lineTo(this.cx, this.cy + this.size);
          ctx.stroke();
          ctx.fillStyle = this.lightColor.replace('light', 70);
          ctx.fillText(this.char, this.cx + this.dx, this.cy + this.dy + this.size);
          if (this.cy + this.size < -hh || this.cx < -hw || this.cy > hw)
            this.phase = 'done';
        }
      }
    };

    function Shard(x, y, vx, vy, color) {
      var vel = opts.fireworkShardBaseVel + opts.fireworkShardAddedVel * Math.random();
      this.vx = vx * vel;
      this.vy = vy * vel;
      this.x = x;
      this.y = y;
      this.prevPoints = [[x, y]];
      this.color = color;
      this.alive = true;
      this.size = opts.fireworkShardBaseSize + opts.fireworkShardAddedSize * Math.random();
    }
    Shard.prototype.step = function () {
      this.x += this.vx;
      this.y += this.vy += opts.gravity;
      if (this.prevPoints.length > opts.fireworkShardPrevPoints)
        this.prevPoints.shift();
      this.prevPoints.push([this.x, this.y]);
      var lineWidthProportion = this.size / this.prevPoints.length;
      for (var k = 0; k < this.prevPoints.length - 1; ++k) {
        var point = this.prevPoints[k],
          point2 = this.prevPoints[k + 1];
        ctx.strokeStyle = this.color.replace('alp', k / this.prevPoints.length);
        ctx.lineWidth = k * lineWidthProportion;
        ctx.beginPath();
        ctx.moveTo(point[0], point[1]);
        ctx.lineTo(point2[0], point2[1]);
        ctx.stroke();
      }
      if (this.prevPoints[0][1] > hh)
        this.alive = false;
    };

    function generateBalloonPath(x, y, size) {
      ctx.moveTo(x, y);
      ctx.bezierCurveTo(x - size / 2, y - size / 2, x - size / 4, y - size, x, y - size);
      ctx.bezierCurveTo(x + size / 4, y - size, x + size / 2, y - size / 2, x, y);
    }

    function anim() {
      window.requestAnimationFrame(anim);
      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, w, h);
      ctx.translate(hw, hh);
      var done = true;
      for (var l = 0; l < letters.length; ++l) {
        letters[l].step();
        if (letters[l].phase !== 'done')
          done = false;
      }
      ctx.translate(-hw, -hh);
      if (done)
        for (var l = 0; l < letters.length; ++l)
          letters[l].reset();
    }

    // Hàm khởi tạo lại vị trí các chữ dựa trên các tham số opts
    function initLetters() {
      letters = [];
      for (var i = 0; i < opts.strings.length; ++i) {
        for (var j = 0; j < opts.strings[i].length; ++j) {
          letters.push(new Letter(
            opts.strings[i][j],
            j * opts.charSpacing + opts.charSpacing / 2 - opts.strings[i].length * opts.charSize / 2,
            i * opts.lineHeight + opts.lineHeight / 2 - opts.strings.length * opts.lineHeight / 2
          ));
        }
      }
    }

    initLetters();
    setTimeout(() => {
      anim();
      ctx.font = opts.charSize + 'px Verdana';
    }, 2000);

    window.addEventListener('resize', function () {
      w = c.width = window.innerWidth;
      h = c.height = window.innerHeight;
      hw = w / 2;
      hh = h / 2;
      updateResponsiveSettings();
      initLetters();
    });
  </script>

  <!-- Phần mã cho hiệu ứng firework -->
  <script>
    window.requestAnimFrame = (function () {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function (callback) {
          window.setTimeout(callback, 1000 / 60);
        };
    })();

    var canvas = document.getElementById('canvas'),
      ctx = canvas.getContext('2d'),
      cw = window.innerWidth,
      ch = window.innerHeight,
      fireworks = [],
      particles = [],
      hue = 120,
      limiterTotal = 5,
      limiterTick = 0,
      timerTotal = 80,
      timerTick = 0,
      mousedown = false,
      mx, my;

    canvas.width = cw;
    canvas.height = ch;

    function random(min, max) {
      return Math.random() * (max - min) + min;
    }

    function calculateDistance(p1x, p1y, p2x, p2y) {
      var xDistance = p1x - p2x,
        yDistance = p1y - p2y;
      return Math.sqrt(Math.pow(xDistance, 2) + Math.pow(yDistance, 2));
    }

    function Firework(sx, sy, tx, ty) {
      this.x = sx;
      this.y = sy;
      this.sx = sx;
      this.sy = sy;
      this.tx = tx;
      this.ty = ty;
      this.distanceToTarget = calculateDistance(sx, sy, tx, ty);
      this.distanceTraveled = 0;
      this.coordinates = [];
      this.coordinateCount = 3;
      while (this.coordinateCount--) {
        this.coordinates.push([this.x, this.y]);
      }
      this.angle = Math.atan2(ty - sy, tx - sx);
      this.speed = 2;
      this.acceleration = 1.05;
      this.brightness = random(50, 70);
      this.targetRadius = 1;
    }

    Firework.prototype.update = function (index) {
      this.coordinates.pop();
      this.coordinates.unshift([this.x, this.y]);
      if (this.targetRadius < 8) {
        this.targetRadius += 0.3;
      } else {
        this.targetRadius = 1;
      }
      this.speed *= this.acceleration;
      var vx = Math.cos(this.angle) * this.speed,
        vy = Math.sin(this.angle) * this.speed;
      this.distanceTraveled = calculateDistance(this.sx, this.sy, this.x + vx, this.y + vy);
      if (this.distanceTraveled >= this.distanceToTarget) {
        createParticles(this.tx, this.ty);
        fireworks.splice(index, 1);
      } else {
        this.x += vx;
        this.y += vy;
      }
    };

    Firework.prototype.draw = function () {
      ctx.beginPath();
      ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
      ctx.lineTo(this.x, this.y);
      ctx.strokeStyle = 'hsl(' + hue + ', 100%, ' + this.brightness + '%)';
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(this.tx, this.ty, this.targetRadius, 0, Math.PI * 2);
      ctx.stroke();
    };

    function Particle(x, y) {
      this.x = x;
      this.y = y;
      this.coordinates = [];
      this.coordinateCount = 5;
      while (this.coordinateCount--) {
        this.coordinates.push([this.x, this.y]);
      }
      this.angle = random(0, Math.PI * 2);
      this.speed = random(1, 10);
      this.friction = 0.95;
      this.gravity = 1;
      this.hue = random(hue - 20, hue + 20);
      this.brightness = random(50, 80);
      this.alpha = 1;
      this.decay = random(0.015, 0.03);
    }

    Particle.prototype.update = function (index) {
      this.coordinates.pop();
      this.coordinates.unshift([this.x, this.y]);
      this.speed *= this.friction;
      this.x += Math.cos(this.angle) * this.speed;
      this.y += Math.sin(this.angle) * this.speed + this.gravity;
      this.alpha -= this.decay;
      if (this.alpha <= this.decay) {
        particles.splice(index, 1);
      }
    };

    Particle.prototype.draw = function () {
      ctx.beginPath();
      ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
      ctx.lineTo(this.x, this.y);
      ctx.strokeStyle = 'hsla(' + this.hue + ', 100%, ' + this.brightness + '%, ' + this.alpha + ')';
      ctx.stroke();
    };

    function createParticles(x, y) {
      var particleCount = 30;
      while (particleCount--) {
        particles.push(new Particle(x, y));
      }
    }

    function loop() {
      requestAnimFrame(loop);
      hue += 0.5;
      ctx.globalCompositeOperation = 'destination-out';
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, cw, ch);
      ctx.globalCompositeOperation = 'lighter';
      var i = fireworks.length;
      while (i--) {
        fireworks[i].draw();
        fireworks[i].update(i);
      }
      var i = particles.length;
      while (i--) {
        particles[i].draw();
        particles[i].update(i);
      }
      if (timerTick >= timerTotal) {
        if (!mousedown) {
          fireworks.push(new Firework(cw / 2, ch, random(0, cw), random(0, ch / 2)));
          timerTick = 0;
        }
      } else {
        timerTick++;
      }
      if (limiterTick >= limiterTotal) {
        if (mousedown) {
          fireworks.push(new Firework(cw / 2, ch, mx, my));
          limiterTick = 0;
        }
      } else {
        limiterTick++;
      }
    }

    window.onload = function () {
      var merrywrap = document.getElementById("merrywrap");
      var box = merrywrap.getElementsByClassName("giftbox")[0];
      var step = 1;
      var stepMinutes = [500, 500, 200, 200];
      function init() {
        box.addEventListener("click", openBox, false);
      }
      function stepClass(step) {
        merrywrap.className = 'merrywrap';
        merrywrap.className = 'merrywrap step-' + step;
      }
      function openBox() {
        if (step === 1) {
          box.removeEventListener("click", openBox, false);
        }
        stepClass(step);
        if (step === 4) {
          reveal();
          return;
        }
        setTimeout(openBox, stepMinutes[step - 1]);
        step++;
      }
      init();
    };

    function reveal() {
      document.querySelector('.merrywrap').style.backgroundColor = 'transparent';
      loop();
      var w, h;
      if (window.innerWidth >= 1000) {
        w = 295;
        h = 185;
      } else {
        w = 255;
        h = 155;
      }
      var ifrm = document.createElement("iframe");
      ifrm.setAttribute("src", "https://www.youtube.com/embed/KDxJlW6cxRk?controls=0&loop=1&autoplay=1");
      ifrm.style.border = 'none';
      document.querySelector('#video').appendChild(ifrm);
    }
  </script>

  <!-- Phần mã cho hiệu ứng balloon -->
  <script>
    const balloonContainer = document.getElementById("balloon-container");

    function random(num) {
      return Math.floor(Math.random() * num);
    }

    function getRandomStyles() {
      var r = random(255);
      var g = random(255);
      var b = random(255);
      var mt = random(200);
      var ml = random(50);
      var dur = random(5) + 5;
      return `
background-color: rgba(${r},${g},${b},0.7);
color: rgba(${r},${g},${b},0.7); 
box-shadow: inset -7px -3px 10px rgba(${r - 10},${g - 10},${b - 10},0.7);
margin: ${mt}px 0 0 ${ml}px;
animation: float ${dur}s ease-in infinite
`;
    }

    function createBalloons(num) {
      for (var i = num; i > 0; i--) {
        var balloon = document.createElement("div");
        balloon.className = "balloon";
        balloon.style.cssText = getRandomStyles();
        balloonContainer.append(balloon);
      }
    }

    window.addEventListener("load", () => {
      createBalloons(30)
    });

    window.addEventListener("click", () => {
      // Nếu có hàm removeBalloons, có thể gọi ở đây
    });
  </script>
</body>

</html>
